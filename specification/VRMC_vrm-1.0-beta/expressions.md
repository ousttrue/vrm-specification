# `VRMC_vrm.expressions`

This document provides specifications for the `expressions` field of the` VRMC_vrm` extension.

Expression is

* MorphTarget
* MaterialColor
* TextureTransform

It is a function to specify the meaning for the group of.

> For example, the combination of `Mouth-to-mouth MorphTarget` and` Eye-closing MorphTarget` should be `sad`.

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [Expression Specification](#expression-specification)
  - [Expression control](#expression-control)
- [Preset Expressions](#preset-expressions)
  - [Emotions](#emotions)
  - [Lip Sync Procedural](#lip-sync-procedural)
  - [Blink procedural](#blink-procedural)
  - [gaze procedural](#gaze-procedural)
  - [Other](#other)
- [Custom Expressions](#custom-expressions)
- [Procedural override](#procedural-override)
  - [MorphTargetBind](#morphtargetbind)
  - [MaterialColorBind](#materialcolorbind)
  - [TextureTransformBind](#texturetransformbind)
- [Expression update algorithm](#expression-update-algorithm)
  - [MorphTarget](#morphtarget)
  - [MaterialColor and TextureTransform](#materialcolor-and-texturetransform)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Expression Specification

`extensions.VRMC_vrm.expressions`

| Name                                   | Remarks                                                                                                       |
|:---------------------------------------|:--------------------------------------------------------------------------------------------------------------|
| expressions [*] .isBinary              | A value greater than 0.5 is 1.0, otherwise 0.0                                                                |
| expressions [*] .morphTargetBinds      | List of MorphTargetBinds (discussed below)                                                                    |
| expressions [*] .materialColorBinds    | List of MaterialValueBinds (discussed below)                                                                  |
| expressions [*] .textureTransformBinds | List of TextureTransformBinds (discussed below)                                                               |
| expressions [*] .overrideMouth         | Manipulates the lip sync (discussed below) weights when the Weight of this Expression is non-zero.            |
| expressions [*] .overrideBlink         | Manipulates the blink (described below) weight when the Weight of this Expression is non-zero.                |
| expressions [*] .overrideLookAt        | Manipulates the weight of the line of sight (discussed below) when the Weight of this Expression is non-zero. |

### Expression control

When each expression is used, it is assumed that it has a "Value" state that represents the strength of its facial expression.
Value is a number with a value in the range [0-1].
The VRM implementation should clamp the value if the application gives a value outside this range.

## Preset Expressions

Below is the list of preset expressions.
These expressions will be stored in `expressions.preset` .
All preset expressions are optional.

### Emotions

| Name      | Remarks                         |
|:----------|:--------------------------------|
| happy     | Changed from `joy`              |
| angry     | anger                           |
| sad       | Changed from `sorrow`           |
| relaxed   | Comfortable. Changed from `fun` |
| surprised | surprised. `Added new in 1.0`   |

There are no specific specifications for facial deformation.

### Lip Sync Procedural

Procedural: A value that can be automatically generated by the system.

> Analyze microphone input, generate from text, etc.

| Name | Remarks |
|:-----|:--------|
| aa   | aa      |
| ih   | i       |
| ou   | u       |
| ee   | eh      |
| oh   | oh      |

### Blink procedural

Procedural: A value that can be automatically generated by the system.

> Randomly blink, etc.

| Name       | Remarks               |
|:-----------|:----------------------|
| blink      | close both eyelids    |
| blinkLeft  | Close the left eyelid |
| blinkRight | Close right eyelid    |

### gaze procedural

Procedural: A value that can be automatically generated by the system.

> The VRM LookAt will generate a value for the gaze point from time to time (see LookAt Expression Type).

| Name      | Remarks                                                                                    |
|:----------|:-------------------------------------------------------------------------------------------|
| lookUp    | For models where the line of sight moves with Expression instead of bone. See eye control. |
| lookDown  | For models where the line of sight moves with Expression instead of bone. See eye control. |
| lookLeft  | For models whose line of sight moves with Expression instead of bone. See eye control.     |
| lookRight | For models where the line of sight moves with Expression instead of bone. See eye control. |

### Other

| Name    | Remarks                           |
|:--------|:----------------------------------|
| neutral | left for backwards compatibility. |

## Custom Expressions

Aside from Preset Expressions, User-defined expressions can be defined.
Custom Expressions will be stored in `expressions.custom` .
Custom Expressions cannot have names that are the same as any Preset Expressions.

## Procedural override

Lip sync, blink, and gaze are classified as procedural.
Procedural assumes that the system will generate it automatically.
As a result, these Expressions are valid at the same time as other Expressions.
The mesh may break.

For example

* `aa` is applied at the same time as` happy` when the mouth opens => The mouth opens too much and becomes strange
* Close eyes `sad` and` blink` are applied => Eyes close twice and eyelids pierce cheeks
* `lookRight` is applied at the same time as` blink` => Eyes penetrate the eyelids

Etc.
To protect against these, there is the ability to override the value of a procedural Expression when procedural Expression is enabled at the same time for a non-procedural Expression.

> Do not lip sync during `happy`

For lip sync, blinking and gaze
You can set overrideMouth, overrideBlink, and overrideLookAt.

Each override property affects the following procedural facial expressions:

| Target   | Properties       | ExpressionPreset                               |
|:---------|:-----------------|:-----------------------------------------------|
| Lip Sync | `overrideMouth`  | ` aa`, `ih`,` ou`, `ee`,` oh`                  |
| Blink    | `overrideBlink`  | ` blink`, `blinkLeft`,` blinkRight`            |
| Gaze     | `overrideLookAt` | ` lookUp`, `lookDown`,` lookLeft`, `lookRight` |

> The specification does not specifically define whether these override properties work for custom facial expressions.
> Make the appropriate settings according to the demand on the application side.
> For example, if you want to use a lip sync that is not included in the VRM preset for each application using a custom facial expression, you can use the override property to control the expression of that custom facial expression.
>
> For the above reasons, it is recommended that VRM implementations provide an interface that allows custom facial expressions to be overridden.

Like overrideBlink for blink, settings for the same kind are treated as invalid.

The settings are all the same, and the effects are as follows.

| Name  | Remarks                                                                                                                                                                            |
|:------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| none  | do nothing                                                                                                                                                                         |
| block | Set the target weight to 0. For example, when overrideBlink = block is set for happy, when happy.weight> 0, the weight of blink, blinkLeft, blinkRight is overridden to 0.         |
| blend | Attenuates the target weight. For example, when overrideBlink = blend is set for happy, blink, blinkLeft, and blinkRight are blended with happy.weight and attenuated (see below). |

blend details

For example, if happy is set to overrideBlink = blend
As the value of happy fades from 0 to 1, it linearly attenuates blink.
The behavior of the intermediate value between 0 and 1 is different from block.

```js
var value = 0;
if (happyWeight > 0 && happy.overrideBlink == "blend") value += happyWeight;
if (angryWeight > 0 && happy.overrideBlink == "blend") value += angryWeight;
if (sadWeight > 0 && happy.overrideBlink == "blend") value += sadWeight;
if (relaxedWeight > 0 && happy.overrideBlink == "blend") value += relaxedWeight;
if (surprisedWeight > 0 && happy.overrideBlink == "blend") value += surprisedWeight;
var factor = 1.0 - saturate(value);
SetBlinkWeight(blinkWeight * factor);
```

### MorphTargetBind

`extensions.VRMC_vrm.expressions [*] .morphTargetBinds [*]`

Connect Expression and MorphTarget.

| Name   | Remarks                                                                   |
|:-------|:--------------------------------------------------------------------------|
| node   | index of target node (has mesh)                                           |
| index  | index of target morph (assuming all primitives have the same morphTarget) |
| weight | morph value when applied [0-1]. In 0.X [0-100]                            |

### MaterialColorBind

`extensions.VRMC_vrm.expressions [*] .materialColorBinds [*]`

Connects the color changes of Expression and Material.

| Name        | Remarks                                                    |
|:------------|:-----------------------------------------------------------|
| material    | index of the target material                               |
| type        | Items to be changed in material (color, uvScale, uvOffset) |
| targetValue | material value when applied (float4)                       |

`extensions.VRMC_vrm.expressions [*] .materialColorBinds [*] .type`

Each corresponds to the following parameters:

| Name          | `pbrMetallicRoughness`                 | ` KHR_materials_unlit`                  | `VRMC_materials_mtoon`                          |
|:--------------|:---------------------------------------|:----------------------------------------|:------------------------------------------------|
| color         | `pbrMetallicRoughness.baseColorFactor` | ` pbrMetallicRoughness.baseColorFactor` | `pbrMetallicRoughness.baseColorFactor`          |
| emissionColor | `emissiveFactor`                       | unused                                  | ` emissiveFactor`                               |
| shadeColor    | Unused                                 | Unused                                  | `extensions.VRMC_materials_mtoon.shadeFactor`   |
| rimColor      | Unused                                 | Unused                                  | `extensions.VRMC_materials_mtoon.rimFactor`     |
| outlineColor  | unused                                 | unused                                  | `extensions.VRMC_materials_mtoon.outlineFactor` |

### TextureTransformBind

`extensions.VRMC_vrm.expressions [*] .textureTransformBinds [*]`

It connects the expression and the change of scale and offset of the texture of the target Material.
Of the textures used in the target material, all UV-accessed textures use the same value.

The texture that does not have UV access is MToon's `matcap`.

| Name     | Remarks                                             |
|:---------|:----------------------------------------------------|
| material | index of the target material                        |
| scale    | scale value when applied (float2, default = [1, 1]) |
| offset   | offset value when applied (float2)                  |

## Expression update algorithm

### MorphTarget

* Weight `float`. Default value: `0`

* Set all MorphTargets to 0
* Accumulate the expression value (Weight) `void AccumulateValue (Expression expression, float value)`
* Apply the integrated value

### MaterialColor

* Color `float4`. Default value: Color of the material property.

* Initialize all MaterialColor
* Accumulate the Expression value (Weight) `void AccumulateValue (Exoressuib expression, float value)`
* Apply the integrated value `Base + (A.Target --Base) * A.Weight + (B.Target --Base) * B.Weight`
   * Since the initial value of MaterialColor is not always `[0, 0, 0, 0]`, the difference from the initial value is added up.

### TextureTransform

* Scale `float2`. Default value: Scale of color texture slot of the material. If not modified, the value is `[1, 1]`.
* Offset `float2`. Default value: Offset of color texture slot of the material. If not modified, the value is `[0, 0]`.

* Initialize all TextureTransform
* Accumulate the value `Base + (A.Target --Base) * A.Weight + (B.Target --Base) * B.Weight`
  * Since the initial value of ScaleOffset is not always `[1, 1, 0, 0]`, the difference from the initial value is added up.
